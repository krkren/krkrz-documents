<?xml version="1.0" encoding="UTF-8" ?>
<doc>
<title>Graphics System</title>

<para>
<ptitle>About the Graphics System</ptitle>
 KiriKiri has a graphic display mechanism based on layers.<r/>
 Each layer has features for transparent overlaying via alpha blending and hierarchical structure management. Additionally, layers have a mechanism for receiving user input (focus) so they can function as GUI components (widgets).<r/>
<r/>
 Overlayed layers are drawn to the window using a mechanism called a draw device. By default, a device called BasicDrawDevice is used, which simply draws the layer output to the window. The draw device can be freely replaced by manipulating the <at href="f_Window_drawDevice.html">Window.drawDevice</at> property, allowing users to define their own production effects (in the form of plugins) according to their needs, but KiriKiri Z only includes the aforementioned BasicDrawDevice.
</para>

<para>
<ptitle>Readable and Writable Image Formats</ptitle>
 In the standard state of KiriKiri, the formats that can be loaded into or written from a layer using <at href="f_Layer_loadImages.html">Layer.loadImages</at> are as follows.<r/>
<r/>
<dl>
<dt>BMP</dt>
<dd>
 Windows standard bitmap format. 32 bpp BMPs are treated as bitmaps with an alpha channel.<r/>
 RLE-compressed bitmaps cannot be loaded.
</dd>

<dt>PNG</dt>
<dd>
 Portable Network Graphic format can be loaded. Bitmaps with an alpha channel (PNG) can also be loaded.
</dd>

<dt>JPEG</dt>
<dd>
 JPEG format can be loaded. Arithmetically compressed or losslessly compressed ones cannot be loaded, but since they are rarely encountered anyway, it should not be a problem.
</dd>

<dt>TLG5</dt>
<dd>
 KiriKiri's original lossless compression format. The extension is .tlg. Those with an alpha channel can also be loaded. The compression ratio is not very high, but it features high-speed expansion. This format <b>cannot be used for mask images (_m) or province images (_p)</b>. It can only handle full-color images without an alpha channel or full-color images with an alpha channel.
</dd>

<dt>TLG6</dt>
<dd>
 KiriKiri's original lossless compression format. The extension is .tlg, the same as TLG5. TLG6 features a high compression ratio. The expansion speed takes slightly less than twice as long as TLG5, but it is still more than twice as fast as PNG, and the size is 20% to 40% smaller than PNG.
</dd>

<dt>JPEG XR</dt>
<dd>
 JPEG XR format can be loaded. It is lossy but has higher image quality than JPEG and supports an alpha channel.<r/>
 If compressed with priority on image quality, it is difficult to distinguish from losslessly compressed images, and since the file size is small, it is useful when size is important.<r/>
 Supported since Ver 1.1.0, currently only loading is supported.<r/>
 Saving is also supported since Ver 1.3.0.<r/>
</dd>

<dt>Main/Mask Separation Format</dt>
<dd>
 The main/mask separation format is a format where the color information image (main) and the alpha channel (mask) image are separated. The mask image is the main image filename with _m appended (for example, abc_m.jpeg for abc.jpeg).<r/>
 The formats of the main and mask images do not have to be the same.
</dd>
</dl>
<r/>
 Additionally, you can increase the number of loadable image formats using Susie Plug-ins. Susie Plug-ins can be loaded using the <at href="f_Plugins_link.html">Plugins.link</at> method.<r/>
 If a 32bpp bitmap is passed from a Susie Plug-in, it is treated as a bitmap with an alpha channel.<r/>
<r/>
</para>

<para>
<ptitle>Layer Types</ptitle>
 KiriKiri layers can be displayed in various composition modes (layer types).<r/>
 The following composition modes are available, and layer type constants starting with lt can be specified in the <at href="f_Layer_type.html">Layer.type</at> property.<r/>
 In the formulas, <i>result</i> is the result, <i>dest</i> is the brightness of the destination image, <i>src</i> is the brightness of the source image to be overlayed, and <i>alpha</i> is the alpha value for each pixel of the source image, with all values ranging from 0.0 to 1.0.<r/>
 Also, the following functions are defined here for explanation purposes:<r/>
<ul>
<li>abs(<i>a</i>) : Absolute value of <i>a</i></li>
<li>max(<i>a</i>, <i>b</i>) : The larger of <i>a</i> or <i>b</i></li>
<li>min(<i>a</i>, <i>b</i>) : The smaller of <i>a</i> or <i>b</i></li>
<li>blend(<i>a</i>, <i>b</i>, <i>r</i>) = <i>a</i> * (1.0 - <i>r</i>) + <i>b</i> * <i>r</i></li>
</ul>

<r/>

<dl>

<dt><kw>ltOpaque</kw> (<kw>ltCoverRect</kw>)</dt>
<dd>
 ltOpaque is a display without transparency. The entire rectangle of the layer is always completely opaque (this is not limited to this layer type, but if the opacity is lowered with <at href="f_Layer_opacity.html">Layer.opacity</at>, it will follow that).<r/>
<r/>
Formula : <i>result</i> = <i>src</i><r/>
<note>
ltCoverRect has the same meaning, but it is an old name from before 2.23 beta 2.
</note>
</dd>

<dt><kw>ltAlpha</kw> (<kw>ltTransparent</kw>)</dt>
<dd>
 ltAlpha performs alpha blending. This is the most basic type for transparency. The following formula is also used for alpha channel input from BMP or Susie plug-ins.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, <i>src</i>, <i>alpha</i>)<r/>
<note>
ltTransparent has the same meaning, but it is an old name from before 2.23 beta 2.
</note>
</dd>

<dt><kw>ltAddAlpha</kw></dt>
<dd>
 ltAddAlpha performs additive alpha blending.<r/>
 You can output images suitable for this format using <link href="TPC" />. Also, you can convert from ltAlpha to this format using the <at href="f_Layer_convertType.html">Layer.convertType</at> method.<r/>
 Layers of type ltAddAlpha cannot be displayed correctly if they are direct children of an ltAlpha layer.<r/>
<r/>
Formula : <i>result</i> = min(1.0, <i>dest</i> * ( 1.0 - <i>alpha</i> ) + <i>src</i>)<r/>
</dd>

<dt><kw>ltAdditive</kw></dt>
<dd>
 ltAdditive performs additive composition. Suitable for expressing glows. It is "Linear Dodge" in Photoshop, but if you want the same effect as Photoshop, use ltPsAdditive described later. Unlike ltPsAdditive, <i>alpha</i> is ignored in ltAdditive.<r/>
 The neutral color (the color that does not change when overlayed) is black.<r/>
<r/>
Formula : <i>result</i> = min(1.0, <i>dest</i> + <i>src</i>)<r/>
</dd>

<dt><kw>ltSubtractive</kw></dt>
<dd>
 ltSubtractive performs subtractive composition. <i>alpha</i> is ignored.<r/>
 The neutral color is white.<r/>
<r/>
Formula : <i>result</i> = max(0.0, <i>dest</i> + <i>src</i> - 1.0)<r/>
<note>
 The only difference from <i>result</i> = <i>dest</i> - <i>src</i> is whether src is inverted or not.
</note>
</dd>

<dt><kw>ltMultiplicative</kw></dt>
<dd>
 ltMultiplicative performs multiplicative composition. <i>alpha</i> is ignored.<r/>
 The neutral color is white.<r/>
<r/>
Formula : <i>result</i> = <i>dest</i> * <i>src</i>
</dd>

<dt><kw>ltDodge</kw></dt>
<dd>
 ltDodge performs "Dodge" composition. Suitable for expressing things illuminated by light. <i>alpha</i> is ignored.<r/>
 The neutral color is black.<r/>
<r/>
Formula : <i>result</i> = min(1.0, <i>dest</i> / ( 1.0 -  <i>src</i> ) )<r/>
</dd>

<dt><kw>ltLighten</kw></dt>
<dd>
 ltLighten performs "Lighten" composition. <i>alpha</i> is ignored.<r/>
 The neutral color is black.<r/>
<r/>
Formula : <i>result</i> = max(<i>dest</i>, <i>src</i>)<r/>
</dd>

<dt><kw>ltDarken</kw></dt>
<dd>
 ltDarken performs "Darken" composition. <i>alpha</i> is ignored.<r/>
 The neutral color is white.<r/>
<r/>
Formula : <i>result</i> = min(<i>dest</i>, <i>src</i>)<r/>
</dd>

<dt><kw>ltScreen</kw></dt>
<dd>
 ltScreen performs "Screen" composition. <i>alpha</i> is ignored.<r/>
 The neutral color is black.<r/>
<r/>
Formula : <i>result</i> = 1.0 - ( 1.0 - <i>dest</i> ) * ( 1.0 - <i>src</i> )<r/>
</dd>



<dt><kw>ltPsNormal</kw></dt>
<dd>
 ltPsNormal has the same effect as ltAlpha. It has a different routine and name from ltAlpha for historical reasons.
</dd>


<dt><kw>ltPsAdditive</kw></dt>
<dd>
 ltPsAdditive performs Photoshop-compatible "Linear Dodge" composition (additive composition). Unlike ltAdditive, <i>alpha</i> is not ignored.<r/>
 The neutral color is black.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, min(1.0, <i>dest</i> + <i>src</i>), <i>alpha</i>)<r/>
</dd>

<dt><kw>ltPsSubtractive</kw></dt>
<dd>
 ltPsSubtractive performs Photoshop-compatible "Linear Burn" composition (subtractive composition). Unlike ltSubtractive, <i>alpha</i> is not ignored.<r/>
 The neutral color is white.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, max(0.0, <i>dest</i> + <i>src</i> - 1.0), <i>alpha</i>)<r/>
</dd>

<dt><kw>ltPsMultiplicative</kw></dt>
<dd>
 ltPsMultiplicative performs Photoshop-compatible "Multiply" composition. Unlike ltMultiplicative, <i>alpha</i> is not ignored.<r/>
 The neutral color is white.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, <i>dest</i> * <i>src</i>, <i>alpha</i>)<r/>
</dd>

<dt><kw>ltPsScreen</kw></dt>
<dd>
 ltPsScreen performs Photoshop-compatible "Screen" composition. Unlike ltScreen, <i>alpha</i> is not ignored.<r/>
 The neutral color is black.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, 1.0 - (1.0 - <i>dest</i>) * (1.0 - <i>src</i>), <i>alpha</i>)<r/>
</dd>


<dt><kw>ltPsOverlay</kw></dt>
<dd>
 ltPsOverlay performs Photoshop-compatible "Overlay" composition.<r/>
 The neutral color is 50% gray.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, overlay(<i>dest</i>, <i>src</i>), <i>alpha</i>)<r/>
Where overlay(<i>a</i>, <i>b</i>) = <r/>
 <i>a</i> * <i>b</i> * 2.0  (when <i>a</i> &lt; 0.5)<r/>
 1.0 - (1.0 - <i>a</i>) * (1.0 - <i>b</i>) * 2.0 (otherwise)<r/>
</dd>

<dt><kw>ltPsHardLight</kw></dt>
<dd>
 ltPsHardLight performs Photoshop-compatible "Hard Light" composition.<r/>
 The neutral color is 50% gray.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, hardlight(<i>dest</i>, <i>src</i>), <i>alpha</i>)<r/>
Where hardlight(<i>a</i>, <i>b</i>) = <r/>
 <i>a</i> * <i>b</i> * 2.0  (when <i>b</i> &lt; 0.5)<r/>
 1.0 - (1.0 - <i>a</i>) * (1.0 - <i>b</i>) * 2.0 (otherwise)<r/>
</dd>


<dt><kw>ltPsSoftLight</kw></dt>
<dd>
 ltPsSoftLight performs Photoshop-compatible "Soft Light" composition.<r/>
 The neutral color is 50% gray.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, softlight(<i>dest</i>, <i>src</i>), <i>alpha</i>)<r/>
Where softlight(<i>a</i>, <i>b</i>) = <r/>
 <i>a</i>^(0.5 / <i>b</i>)  (when <i>b</i> &gt; 0.5)<r/>
 <i>a</i>^((1.0 - <i>b</i>) * 2)  (otherwise)<r/>
</dd>


<dt><kw>ltPsColorDodge</kw></dt>
<dd>
 ltPsColorDodge performs Photoshop-compatible "Color Dodge" composition. Unlike ltDodge, <i>alpha</i> is not ignored.<r/>
 The neutral color is black.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, min(1.0, <i>dest</i> / ( 1.0 -  <i>src</i> ) ), <i>alpha</i>)<r/>
</dd>

<dt><kw>ltPsColorDodge5</kw></dt>
<dd>
 ltPsColorDodge5 performs "Color Dodge" composition compatible with Photoshop version 5.x and earlier. The formula is slightly different from ltPsColorDodge.<r/>
 The neutral color is black.<r/>
<r/>
Formula : <i>result</i> = min(1.0, <i>dest</i> / ( 1.0 - <i>src</i> * <i>alpha</i>) )<r/>
</dd>

<dt><kw>ltPsColorBurn</kw></dt>
<dd>
 ltPsColorBurn performs Photoshop-compatible "Color Burn" composition.<r/>
 The neutral color is white.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, max(0.0, 1.0 - (1.0 - <i>dest</i>) / <i>src</i>), <i>alpha</i>)<r/>
</dd>

<dt><kw>ltPsLighten</kw></dt>
<dd>
 ltPsLighten performs Photoshop-compatible "Lighten" composition. Unlike ltLighten, <i>alpha</i> is not ignored.<r/>
 The neutral color is black.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, max(<i>dest</i>, <i>src</i>), <i>alpha</i>)<r/>
</dd>

<dt><kw>ltPsDarken</kw></dt>
<dd>
 ltPsDarken performs Photoshop-compatible "Darken" composition. Unlike ltDarken, <i>alpha</i> is not ignored.<r/>
 The neutral color is white.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, min(<i>dest</i>, <i>src</i>), <i>alpha</i>)<r/>
</dd>

<dt><kw>ltPsDifference</kw></dt>
<dd>
 ltPsDifference performs Photoshop-compatible "Difference" composition.<r/>
 The neutral color is black.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>, abs(<i>dest</i> - <i>src</i>), <i>alpha</i>)<r/>
</dd>

<dt><kw>ltPsDifference5</kw></dt>
<dd>
 ltPsDifference5 performs "Difference" composition compatible with Photoshop version 5.x and earlier. The formula is slightly different from ltPsDifference.<r/>
 The neutral color is black.<r/>
<r/>
Formula : <i>result</i> = abs(<i>dest</i> - <i>src</i> * <i>alpha</i>)<r/>
</dd>

<dt><kw>ltPsExclusion</kw></dt>
<dd>
 ltPsExclusion performs Photoshop-compatible "Exclusion" composition.<r/>
 The neutral color is black.<r/>
<r/>
Formula : <i>result</i> = blend(<i>dest</i>,  <i>dest</i> + <i>src</i> - 2.0 * <i>src</i> * <i>dest</i>, <i>alpha</i>)<r/>
</dd>



</dl>

</para>






<para>
<ptitle>Alpha Blending and Additive Alpha Blending</ptitle>
 KiriKiri has two alpha blending modes.<r/>
<dl>
<dt>Alpha Blending</dt>
<dd>
 Specifying <kw>ltAlpha</kw> in the <at href="f_Layer_type.html">Layer.type</at> property results in this display type.<r/>
 ltAlpha is the alpha blending mode adopted by many graphics software. This mode is suitable when loading data output from other graphics software as is.<r/>
</dd>

<dt>Additive Alpha Blending</dt>
<dd>
 Specifying <kw>ltAddAlpha</kw> in the <at href="f_Layer_type.html">Layer.type</at> property results in this display type.<r/>
 This format has the following advantages and disadvantages compared to alpha blending:<r/>
<ul>
<li>The formula is simpler than alpha blending, so display can be performed at high speed, and high-speed drawing is possible with many drawing methods</li>
<li>Additive composition can be expressed along with alpha blending</li>
<li>There is almost no graphics software that supports this format</li>
</ul>
<r/>
 Since there are likely not many graphics software programs that support the same composition mode as ltAddAlpha, to handle output from other software in this format in KiriKiri, you need to output this type of image with <link href="TPC" /> or convert from ltAlpha to this format using the <at href="f_Layer_convertType.html">Layer.convertType</at> method.<r/>
 In the Image Format Converter, you can accept input that combines "Normal" layers and "Linear Dodge" layers in Photoshop format as input for additive alpha blending images.<r/>
</dd>

</dl>

</para>






<para>
<ptitle>Layer Types, Drawing Methods, and Operation Modes</ptitle>
 KiriKiri has layer types (specified by constants starting with lt), drawing methods (specified by constants starting with df), and operation modes (specified by constants starting with om).<r/>
 Although they have similar names, their uses are divided as follows:<r/>
<dl>

<dt>Layer Type</dt>
<dd>
 The layer type is the value specified in the <at href="f_Layer_type.html">Layer.type</at> property and determines how the layer is displayed.
</dd>

<dt>Drawing Method</dt>
<dd>
 The drawing method is the value specified in the <at href="f_Layer_face.html">Layer.face</at> property and determines how to draw onto the layer. If dfAuto is specified, the appropriate drawing method is determined according to the layer type. You can also draw using a drawing method different from the one optimal for the layer type.<r/>
 In methods that perform copying between layers, such as the <at href="f_Layer_copyRect.html">Layer.copyRect</at> method, it is also used to select which information to copy. In the case of dfBoth (or dfAlpha or dfAddAlpha), both the main and mask are copied. In the case of dfMain (or dfOpaque), only the main is copied. In the case of dfMask, only the mask is copied, and in the case of dfProvince, only the province image is copied.<r/>
 Similarly, in the <at href="f_Layer_fillRect.html">Layer.fillRect</at> method, it is used to select which information to fill. In the case of dfBoth (or dfAlpha or dfAddAlpha), both the main and mask are filled. In the case of dfMain (or dfOpaque), only the main is filled. In the case of dfMask, only the mask is filled, and in the case of dfProvince, only the province image is filled.<r/>
</dd>

<dt>Operation Mode</dt>
<dd>
 The operation mode is the value specified in arguments of methods such as <at href="f_Layer_operateRect.html">Layer.operateRect</at> and determines how to handle the operation source (the layer to be overlayed). If omAuto is specified, the appropriate mode is determined according to the layer type of the operation source.
</dd>

</dl>
</para>


<para>
<ptitle>Alpha Channel Protection</ptitle>
 When the drawing method specified in the <at href="f_Layer_face.html">Layer.face</at> property is <kw>dfOpaque</kw>, you can specify whether to protect the alpha channel of the drawing destination (the layer on which you are trying to execute the method) using the <at href="f_Layer_holdAlpha.html">Layer.holdAlpha</at> property.<r/>
 If the alpha channel is protected, the alpha channel (opacity) is preserved, and transparent parts remain transparent.<r/>
 If the alpha channel is not protected, the alpha channel (opacity) is destroyed. To be destroyed means that the state becomes unpredictable.<r/>
 However, if the <at href="f_Layer_type.html">Layer.type</at> property is neither <kw>ltAlpha</kw> nor <kw>ltAddAlpha</kw>, the layer's alpha channel is not used, so there is usually no problem even if the Layer.holdAlpha property is set to false. Also, if set to false, drawing can be performed faster in many methods than when set to true.<r/>
</para>


</doc>
<?xml version="1.0" encoding="UTF-8" ?>
<doc>
<title>WaveSoundBuffer</title>
<desc>
 The WaveSoundBuffer class is a class that manages <wave>PCM playback</wave>.<r/>
<wave>
 The WaveSoundBuffer class can load and process .sli files created with the <link href="LoopTuner" />. For details, please refer to the Loop Tuner documentation.<r/>
</wave>
</desc>

<member>
	<name>WaveSoundBuffer</name>
	<type>constructor</type>
	<shortdesc>Constructs a WaveSoundBuffer object</shortdesc>
	<arg>
		<argitem>
			<name>owner</name>
			<default></default>
			<desc>
				 Specifies the destination for events.<r/>
			</desc>
		</argitem>
	</arg>
	<result></result>
	<desc>
		 Constructs an object of the WaveSoundBuffer class.<r/>
		 When an event occurs, it calls the action method of the object specified by owner. If null is specified for owner, the action method is not called. Usually, a <ref>Window</ref> class object is specified as the owner.<r/>
	</desc>
</member>


<member>
	<name>onStatusChanged</name>
	<type>event</type>
	<shortdesc>Status changed</shortdesc>
	<arg>
		<argitem>
			<name>status</name>
			<default></default>
			<desc>
				 The new status.<r/>
				 Refer to the <ref>WaveSoundBuffer.status</ref> property.<r/>
			</desc>
		</argitem>
	</arg>
	<result></result>
	<desc>
		 Occurs when the playback status (state) changes.<r/>
	</desc>
</member>

<wave>
<member>
	<name>onLabel</name>
	<type>event</type>
	<shortdesc>Passed a label</shortdesc>
	<arg>
		<argitem>
			<name>name</name>
			<default></default>
			<desc>
				 The name of the label passed.<r/>
			</desc>
		</argitem>
	</arg>
	<result></result>
	<desc>
		 Occurs when the playback position passes a label.<r/>
	</desc>
</member>
</wave>

<member>
	<name>onFadeCompleted</name>
	<type>event</type>
	<shortdesc>Fade completed</shortdesc>
	<arg>
	</arg>
	<result></result>
	<desc>
		 Occurs when a fade started with the <ref>WaveSoundBuffer.fade</ref> method finishes.<r/>
	</desc>
</member>


<member>
	<name>open</name>
	<type>method</type>
	<shortdesc>Open media</shortdesc>
	<arg>
		<argitem>
			<name>storage</name>
			<default></default>
			<desc>
				
				<wave> Specifies the storage to play.<r/></wave>
				
			</desc>
		</argitem>
	</arg>
	<result></result>
	<desc>
		 Opens the specified media. This method does not start playback.<r/>
		<wave> If there is a file name with .sli appended to the specified storage name, it is loaded as sound loop information.<r/></wave>
	</desc>
</member>

<member>
	<name>play</name>
	<type>method</type>
	<shortdesc>Play media</shortdesc>
	<arg>
	</arg>
	<result></result>
	<desc>
		 Starts playback of the media.<r/>
	</desc>
</member>

<member>
	<name>stop</name>
	<type>method</type>
	<shortdesc>Stop media</shortdesc>
	<arg>
	</arg>
	<result></result>
	<desc>
		 Stops the media.<r/>
	</desc>
</member>

<member>
	<name>fade</name>
	<type>method</type>
	<shortdesc>Start fade</shortdesc>
	<arg>
		<argitem>
			<name>to</name>
			<default></default>
			<desc>
				 Specifies the target volume.<r/>
				 Refer to the <ref>WaveSoundBuffer.volume</ref> property for volume specification.<r/>
			</desc>
		</argitem>
		<argitem>
			<name>time</name>
			<default></default>
			<desc>
				 Specifies the time for the fade in ms.<r/>
			</desc>
		</argitem>
		<argitem>
			<name>delay</name>
			<default>0</default>
			<desc>
				 Specifies the wait time until the fade starts in ms.<r/>
			</desc>
		</argitem>
	</arg>
	<result></result>
	<desc>
		 Starts a fade (continuous volume change).<r/>
	</desc>
</member>

<member>
	<name>stopFade</name>
	<type>method</type>
	<shortdesc>Stop fade</shortdesc>
	<arg>
	</arg>
	<result></result>
	<desc>
		 Forcibly stops the fade started with the <ref>WaveSoundBuffer.fade</ref> method.<r/>
		 The volume remains as it was at the time of stopping.<r/>
	</desc>
</member>

<wave>
<member>
	<name>freeDirectSound</name>
	<type>method</type>
	<shortdesc>Release DirectSound</shortdesc>
	<arg>
	</arg>
	<result></result>
	<desc>
		 Releases DirectSound. All WaveSoundBuffer class objects will enter a stopped state.<r/>
		 Use this method to release DirectSound in environments where playback via DirectSound and WaveMapper (MCI, etc.) cannot be performed simultaneously.<r/>
		 This method exists only on the WaveSoundBuffer class (it is not available on objects created from WaveSoundBuffer). Use it as WaveSoundBuffer.freeDirectSound();.<r/>
	</desc>
</member>
</wave>



<wave>
<member>
	<name>getVisBuffer</name>
	<type>method</type>
	<shortdesc>Get visualization data</shortdesc>
	<arg>
		<argitem>
			<name>buffer</name>
			<default></default>
			<desc>
				 Specifies the buffer to write the output data to.<r/>
				 The buffer must be an array of 16-bit signed integers, with enough elements (numsamples * channels or more) to hold the samples specified by the numsamples and channels arguments.<r/>
				 If a value other than 1 is specified for channels, the samples for each channel are stored interleaved (e.g., Right Left Right Left... for stereo).<r/>
				 A pointer to the first element of the array must be specified, but please pass it cast to an integer type.<r/>
			</desc>
		</argitem>
		<argitem>
			<name>numsamples</name>
			<default></default>
			<desc>
				 Specifies the number of samples to retrieve.<r/>
			</desc>
		</argitem>
		<argitem>
			<name>channel</name>
			<default></default>
			<desc>
				 Specifies the number of channels to retrieve.<r/>
				 If 1 is specified, you get the data as-is for mono, or downmixed to 1 channel otherwise.<r/>
				 If a value other than 1 is specified, you must specify the same number of channels as the sound currently playing. In this case, you get the data as-is.<r/>
			</desc>
		</argitem>
		<argitem>
			<name>ahead</name>
			<default>0</default>
			<desc>
				 Specifies the number of samples to read ahead.<r/>
				 Retrieves samples starting from the position specified by this argument ahead of the current playback position.<r/>
				 If 0 is specified or this argument is omitted, retrieval starts from the current playback position.<r/>
			</desc>
		</argitem>
	</arg>
	<result>Returns the number of samples successfully retrieved.</result>
	<desc>
		 Retrieves PCM data for visualization.<r/>
		 Reads PCM data from the current playback position and writes it to the array specified by the buffer argument.<r/>
		 However, depending on the buffer state or playback format, data may not be read correctly.<r/>
		 This method is intended for use from plugins written in C, C++, etc., so you cannot, for example, specify a TJS array for the buffer argument.<r/>
		 To use this method, the <ref>WaveSoundBuffer.useVisBuffer</ref> property must be set to true.<r/>
	</desc>
</member>
</wave>

<member>
	<name>position</name>
	<type>property</type>
	<shortdesc>Playback position</shortdesc>
	<access>r/w</access>
	<desc>
		 Represents the playback position in ms. Setting a value moves to that position.<r/>
		
		
	</desc>
</member>

<wave>
<member>
	<name>samplePosition</name>
	<type>property</type>
	<shortdesc>Playback position</shortdesc>
	<access>r/w</access>
	<desc>
		 Represents the playback position in number of samples. Setting a value moves to that position.<r/>
	</desc>
</member>
</wave>
<member>
	<name>paused</name>
	<type>property</type>
	<shortdesc>Whether it is paused</shortdesc>
	<access>r/w</access>
	<desc>
		 Represents whether it is in a paused state. A value can also be set.<r/>
		 If true, it is in a paused state.<r/>
		
		
	</desc>
</member>

<member>
	<name>totalTime</name>
	<type>property</type>
	<shortdesc>Media playback time</shortdesc>
	<access>r</access>
	<desc>
		 Represents the total playback time of the media in ms.<r/>
		
		
	</desc>
</member>

<member>
	<name>looping</name>
	<type>property</type>
	<shortdesc>Whether to perform loop playback</shortdesc>
	<access>r/w</access>
	<desc>
		 Represents whether to perform loop playback. A value can also be set.<r/>
		 If true is specified, loop playback is performed.<r/>
		<wave> Even if false is specified, if the media being played has loop information, that information will be used.<r/></wave>
	</desc>
</member>

<member>
	<name>volume</name>
	<type>property</type>
	<shortdesc>Volume</shortdesc>
	<access>r/w</access>
	<desc>
		 Represents the playback volume. A value can also be set.<r/>
		Specified as a value from 0 to 100000, where 0 is complete mute and 100000 is 100% volume.<r/>
	</desc>
</member>

<member>
	<name>volume2</name>
	<type>property</type>
	<shortdesc>Secondary volume</shortdesc>
	<access>r/w</access>
	<desc>
		 Represents the playback volume. A value can be set.<r/>
		 Unlike the <ref>WaveSoundBuffer.volume</ref> property, this property does not change even with the <ref>WaveSoundBuffer.fade</ref> method.<r/>
		 The final volume is determined by the product of the volume property and this property. If the volume property is 100000 (100%) and the volume2 property is also 100000 (100%), it plays at 100% x 100% = 100% volume. If the volume property is 50000 (50%) and the volume2 property is 75000 (75%), it plays at 50% x 75% = 37.5% volume.<r/>
	</desc>
</member>

<member>
	<name>status</name>
	<type>property</type>
	<shortdesc>Status</shortdesc>
	<access>r</access>
	<desc>
		 Represents the current state.<r/>
		 The state is represented by a string and takes the following values:<r/>
		<tt>"<kw>unload</kw>"   : </tt> Media is not open<r/>
		<tt>"<kw>play</kw>"     : </tt> Media is playing<r/>
		<tt>"<kw>stop</kw>"     : </tt> Media is stopped<r/>
	</desc>
</member>

<wave>
<member>
	<name>useVisBuffer</name>
	<type>property</type>
	<shortdesc>Whether to use the visualization buffer</shortdesc>
	<access>r/w</access>
	<desc>
		 Represents whether to use the visualization buffer. A value can also be set.<r/>
		 If true is specified, the visualization buffer becomes available, and the <ref>WaveSoundBuffer.getVisBuffer</ref> method can be used.<r/>
		 It is false by default. Note that specifying true will consume more memory and CPU time than specifying false.<r/>
	</desc>
</member>
</wave>

<wave>
<member>
	<name>channels</name>
	<type>property</type>
	<shortdesc>Number of channels</shortdesc>
	<access>r</access>
	<desc>
		 Represents the number of channels of the sound currently playing.<r/>
		 It is 1 for mono and 2 for stereo.<r/>
		 It may not return a valid value if no media is open.<r/>
	</desc>
</member>
</wave>

<wave>
<member>
	<name>frequency</name>
	<type>property</type>
	<shortdesc>Sampling frequency</shortdesc>
	<access>r/w</access>
	<desc>
		 Represents the sampling frequency of the sound currently playing. A value can also be set.<r/>
		 It is 44100 for the same sampling frequency as a CD.<r/>
		 It may not return a valid value if no media is open.<r/>
		 Setting a value plays at that frequency.<r/>
	</desc>
</member>
</wave>

<wave>
<member>
	<name>bits</name>
	<type>property</type>
	<shortdesc>Quantization bits</shortdesc>
	<access>r</access>
	<desc>
		 Represents the number of quantization bits of the sound currently playing.<r/>
		 It is 16 for the same quantization bits as a CD.<r/>
		 It may not return a valid value if no media is open.<r/>
	</desc>
</member>
</wave>

<wave>
<member>
	<name>flags</name>
	<type>property</type>
	<shortdesc>Flags</shortdesc>
	<access>r</access>
	<desc>
		 Retrieves an object representing flags.<r/>
		 This object has properties from 0 to 15, each representing the value of a flag. Properties can be accessed using the indirect member selection operator ('[ ]' operator). Values can also be set for these properties. The value range is 0 to 9999, and cannot be lower or higher.<r/>
		 The count property of this object always returns 16.<r/>
		 This object has a reset method; executing it resets all flags to 0.<r/>
		 If no media is open, setting values to this object's properties will be ignored.<r/>
		 This object may look like an array object at first glance, but it is not a so-called TJS array object (an object of the 'Array' class).<r/>
		 Flags are all reset to 0 by the <ref>WaveSoundBuffer.open</ref> method.<r/>
<example>
var buf = new WaveSoundBuffer(window);<r/>
(omitted)<r/>
buf.flags.reset(); // Reset all flags to 0<r/>
var cnt = buf.flags.count; // cnt will be 16<r/>
buf.flags[4] = 34; // Assign 34 to flag number 4<r/>
</example>
	</desc>
</member>
</wave>

<wave>
<member>
	<name>labels</name>
	<type>property</type>
	<shortdesc>Labels</shortdesc>
	<access>r</access>
	<desc>
		 Retrieves an object representing labels.<r/>
		 This object is a dictionary array containing elements whose member names are the label names in the loop information. Each element is also a dictionary array, where the name member represents the label name, the position member represents the label position in milliseconds, and samplePosition represents the label position in number of samples.<r/>
		 Consider this dictionary array to be read-only. Assigning values or creating new members will not be reflected.<r/>
<example>
var buf = new WaveSoundBuffer(window);<r/>
(omitted)<r/>
debug.message(buf.labels['start'].position); // Position of the label named 'start' in milliseconds<r/>
debug.message(buf.labels['start'].samplePosition); // Position of the label named 'start' in number of samples<r/>
</example>
	</desc>
</member>
</wave>

<wave>
<member>
	<name>pan</name>
	<type>property</type>
	<shortdesc>Pan</shortdesc>
	<access>r/w</access>
	<desc>
		 Represents the pan (sound image position). A value can also be set.<r/>
		 Specifies the left/right position where the sound is heard.<r/>
		 Specified as a value from -100000 to 0 to 100000, where -100000 is completely left, 0 is center, and 100000 is completely right.<r/>
	</desc>
</member>
</wave>

<wave>
<member>
	<name>globalVolume</name>
	<type>property</type>
	<shortdesc>Global volume</shortdesc>
	<access>r/w</access>
	<desc>
		 Represents the global volume (master volume). A value can also be set.<r/>
		 This volume affects all WaveSoundBuffers.<r/>
		 Specified as a value from 0 to 100000, where 0 is complete mute and 100000 is 100% volume. The default value is 100000.<r/>
		 This property exists only on the WaveSoundBuffer class (it is not available on objects created from WaveSoundBuffer). Use it as WaveSoundBuffer.globalVolume.<r/>
	</desc>
</member>
</wave>

<wave>
<member>
	<name>globalFocusMode</name>
	<type>property</type>
	<shortdesc>Focus mode</shortdesc>
	<access>r/w</access>
	<desc>
		 Represents the focus mode. A value can also be set.<r/>
		 Focus mode is a mode that mutes when the application is minimized or becomes inactive.<r/>
		 Specifying <tt><kw>sgfmNeverMute</kw></tt> will not mute regardless of the application state.<r/>
		 Specifying <tt><kw>sgfmMuteOnMinimize</kw></tt> will mute when the application is minimized.<r/>
		 Specifying <tt><kw>sgfmMuteOnDeactivate</kw></tt> will mute when the application is deactivated.<r/>
		 This property exists only on the WaveSoundBuffer class (it is not available on objects created from WaveSoundBuffer). Use it as WaveSoundBuffer.globalFocusMode.<r/>
		 The '-wsmute' (DirectSound mute) setting specified in the command line options takes precedence over this property setting.<r/>
	</desc>
</member>
</wave>

<wave>
<member>
	<name>filters</name>
	<type>property</type>
	<shortdesc>Filter array</shortdesc>
	<access>r</access>
	<desc>
		 An array (instance of the Array class) holding insertion filter objects.<r/>
		 By registering filter objects in this array, various effects can be applied to the audio in real-time during playback.<r/>
		 Changes to the filter array are only reflected when the <ref>WaveSoundBuffer.open</ref> method is executed. Until then, changes to this array will not take effect.<r/>
<example>
var buf = new WaveSoundBuffer(window);<r/>
(omitted)<r/>
buf.filters.clear(); // Clear the filter array<r/>
buf.filters.add(new WaveSoundBuffer.PhaseVocoder()); // Add PhaseVocoder filter<r/>
buf.filters[0].time = 0.5; // Double speed playback<r/>
</example>
	</desc>
</member>
</wave>



</doc>
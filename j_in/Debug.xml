<?xml version="1.0" encoding="UTF-8" ?>
<doc>
<title>Debugging</title>

<para>
<ptitle>About Application Debugging</ptitle>
 Debugging is the process of identifying and fixing bugs (causes of malfunctions or unintended behavior) within an application.<r/>
 KiriKiri provides several debugging support features. This section explains how to use these features to debug your application.
</para>

<para>
<ptitle>Debug Message Output</ptitle>
KiriKiri provides several windows to assist with debugging. Please refer to the descriptions in each link for details.<r/>
<dl>
<dt><link href="Console"/></dt>
<dd>Displays various debug messages output by the KiriKiri system and user scripts.</dd>
</dl>
<r/>
 In the console specifically, messages output by the user program using <at href="f_Debug_message.html">Debug.message</at> are displayed. By calling this method at any point in the program, you can display variable contents in the console and inspect them during execution.<r/>
 For information on how to display messages in the console or write logs to a file, refer to the "Debug-related options" in <link href="CommandLine" /> or the <at href="f_Debug.html">Debug class</at>.<r/>
</para>


<para>
<ptitle>Debug Mode</ptitle>
 By specifying '-debug' in the <link href="CommandLine" /> (setting "Debug Mode" to 'enabled'), you can run KiriKiri in debug mode.<r/>
 In debug mode, TJS2 execution becomes slower, but several features useful for debugging are enabled.<r/>
<r/>
<dl>
<dt>Type Information Tracking</dt>
<dd>
 Information regarding TJS2 objects is enhanced.<r/>
 When not in debug mode, for example, if you try to get information for kag.saveSystemVariables in KAG:
<bq>
Console : kag.saveSystemVariables = (object)(object 0x0279E130:0x01EB0BD4)
</bq>
 is all you get, but when debug mode is enabled:
<bq>
Console : kag.saveSystemVariables = (object)(object 0x0279E130[(function) KAGWindow.saveSystemVariables]:0x01EB0BD4[instance of class KAGWindow])
</bq>
 type information is obtained as shown above. (Of the two parts separated by ':', the first part is the object type, and the second part is the context in which the object operates).<r/>
 This option is almost essential when tracing with a debugger.<r/>
 This feature (in the current version) is active throughout the entire process of converting an object to a string.<r/>
</dd>
<dt>Object Leak Detection</dt>
<dd>
 Enables a feature that warns about objects that have not been deleted (released) upon termination.<r/>
 TJS2 normally deletes created objects automatically via garbage collection, so explicit deletion instructions are not required. However, objects may remain undeleted (leak) due to bugs in plugins or the KiriKiri core, or because of circular references.<r/>
 In debug mode, objects that have not been released by the time the application terminates are written to the console log file.<r/>
 Please note that even if only a single object is not released, all objects related to it will be detected, which may result in a very large log file.<r/>
<r/>
 The <at href="f_System_exit.html">System.exit</at> method terminates the application in a manner close to a forced shutdown. Please be aware that terminating the application with this method will cause many objects to leak and a large amount of logs to be recorded.<r/>
<note>
A circular reference is a situation where A refers to B, and B refers to A.<r/>
For example, the following script creates a circular reference:
<bq>
var a = %[], b = %[];<r/>
a.b = b; b.a = a;
</bq>
In this situation, object 'a' requires 'b', and object 'b' requires 'a'. Since the garbage collection method used by TJS2 (reference counting) has difficulty detecting such situations to release objects, TJS2 does not detect them. Therefore, these objects will never be deleted (you can break the circular reference by explicitly invalidating one of the objects using the 'invalidate' operator).<r/>
<r/>
In plugins, incorrect handling of reference counters can lead to object leaks. When creating a plugin and handling TJS2 objects within it, please pay close attention to reference counter management.<r/>
</note>
</dd>
<dt>Warning for Script Execution on Objects Being Deleted</dt>
<dd>
 The finalize method is called when an object is deleted or invalidated.<r/>
 In TJS2, the timing of object deletion is non-deterministic, so the finalize method may be called at an unexpected time, potentially causing unintended behavior. In debug mode, a warning will be displayed in the console when the finalize method is called during such "unstable timing"-specifically, when an object that was not invalidated is deleted by garbage collection.<r/>
 The warning looks like this:<r/>
<bq>
Warning: anonymous@0x016DFA7C(9)[(function) finalize]: Code is being executed on object 0x0167DD44[instance of class A] which is being deleted. The call stack at the time of this object's creation is as follows:<r/>
                     anonymous@0x016DFA7C(13)[(top level script) global]
</bq>
 To prevent such situations, it is recommended to explicitly invalidate objects created with 'new' using the 'invalidate' operator once they are no longer needed.<r/>
 However, for objects of classes like Array, Dictionary, or Date, which either do not have a finalize method or do not perform problematic actions within it, explicit invalidation may not be necessary.<r/>
 The above warning is displayed when an object is about to be deleted without explicit invalidation, and TJS2 script is about to be executed within that context.
</dd>

<dt>Call Stack Retrieval Feature</dt>
<dd>
 Allows the TJS2 function/method call stack to be retrieved from a script.<r/>
 This is done using the <at href="f_Scripts_getTraceString.html">Scripts.getTraceString</at> method.<r/>
 If there is a problem in the middle of a program and you do not know where a method was called from, you can use this method to output the call stack to the console.<r/>
</dd>


</dl>

</para>

</doc>